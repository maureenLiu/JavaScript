<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>

</body>
</html>
<script>
  <!-- 1、认知关键字new：它也是调用函数一种方式 -->
  //函数声明部分
  function Fun (){
   console.log("兄弟你执行呀");
  }
  //关键字new 也是调用函数一种手段
  //构造函数务必、必须、一定是一个关键字new调用的【决定性因素】
  // 用new调用了Fun函数，所以Fun函数才是构造函数
  new Fun;
  new Fun;
  new Fun;
</script>
<script>
	<!-- 2、构造函数的基本使用 -->
   //构造函数两个特征:
   //1、：构造函数的首个英文字母一般大写的【不是决定性因素】
   //2、：函数如果是new调用的，称之为构造函数【决定性因素】

   //问题：函数名+小括号调用函数执行、new调用函数也执行，两者有什么区别？
   function People(){
     //第一步：在函数体中神秘创建了一个空的狭义对象(大的花括号)
     //第二步:函数体中上下文指向当前这个空的狭义对象
     //第三步：可以通过点语法给狭义对象动态添加属性、方法
     this.xingming = "小明";
     this.age = 18;
     this.sex = "男";
     this.hobby = ['吃饭','睡觉','打豆豆'];
     //第四步：虽然没有关键字return，但是系统会自动将狭义对象返回 
   }
   var obj = new People;
   console.log(obj); //结果为People {xingming: "小明", age: 18, sex: "男", hobby: Array(3)}
</script>
<script>
	<!-- 3、构造函数的深入学习 -->
    //构造函数两个特征：
    //函数名字首个英文字母需要大写的
    //函数务必使用关键字new调用的
    function Dog(name,sex,age){
      //构造函数独有四步走
      //第一步：在函数体中神秘创建了一个空的狭义对象
      //第二步：函数的上下文指向当前的空的狭义对象
      //第三步：通过"."语法动态给狭义对象添加属性、方法
       this.name = name;
       this.sex  = sex;
       this.age = age;
      //第四步：虽然没有关键字new，但是系统会将当前这个狭义对象返回
      for(var i = 0 ; i < 10 ;i++){};
      if(true){};
    }
    //调用函数
    var erha =  new Dog("二哈","公",3);
    var taidi  =  new Dog("泰迪","母",6);
    console.log(erha,taidi);
    //因为这是两个不同对象，因为在堆空间当中内存地址不同
    console.log(erha === taidi);//false
</script>
<script>
	<!-- 4、原型 -->
    //任意构造函数 天生都有一个 prototype属性 ，指向一个空的狭义对象
    //创建出来的实例天生拥有一个__proto__属性，可以向上面的狭义对象借用方法使用
    function Dog(name,age,sex){
        //经历四步走
        this.name = name;
        this.age = age;
        this.sex  = sex;
    }   
    console.log(Dog.prototype); //空的狭义对象：{constructor: ƒ}
    Dog.prototype.yaoren = function(){
        console.log("我可以咬人");
    }
    //创建二哈实例
    var erha = new Dog("二哈",18,"公");  
    console.log(erha); 
    erha.yaoren();
    erha.yaoren();
</script>

